----------------------------------------------------------------------------------------------------
-------------------------			RAPPORT			   -------------------------
----------------------------------------------------------------------------------------------------

1.5 
	Vincent : 
		-vim
1.6.3
	- random pour jouer des coups aléatoire lors de situation spécifique

4. Intelligence Artificielle - Heuristique
	4.1. Algorithme
		4.1.1. Elements technique

			* Algorithme (4.1.2.) :
				Un algorithme est une suite finie et non ambiguë d’opérations 
				ou d'instructions permettant de résoudre une classe de problèmes.
				
				https://fr.wikipedia.org/wiki/Algorithme

			* Arbre (4.1.2.) :
				Un arbre en informatique est consititué d'arêtes (appelé branche),
				d'états non finis (appelé noeud) et finis (appelé feuille). Chaques
				branches mênent à un état à l'aide d'une action à partir d'un état
				précédent (père). On appelle feuille un état qui ne possède pas d'état 
				suivant (fils). La racine de l'arbre est appelé l'état initial.

			* Algorithme MinMax (4.1.2.) :
				L'algorithme minimax (aussi appelé algorithme MinMax) est un 
				algorithme qui s'applique à la théorie des jeux1 pour les jeux à 
				deux joueurs à somme nulle (et à information complète) consistant à
				minimiser la perte maximum (c'est-à-dire dans le pire des cas).

				https://fr.wikipedia.org/wiki/Algorithme_minimax

			* Profondeur de recherche (4.1.4.):
				La profondeur de recherche dans les algorithmes s'appliquant à la
				théorie des jeux, est la limite du niveau qui peut être parcouru
				depuis l'état initial aux noeuds de l'arbre.			

		4.1.2. Nécessités

			* Jouer des coups victorieux dans le jeu Tron 
				Pour jouer une partie, le programme doit savoir prendre une décision
			sur la direction que doit emprinter un joueur. La façon la plus pratique est
			de simuler tout les déplacement possibles à partir d'une position donnée, 
			puis repéter ce processus sur plusieurs tour de jeu. Ce qui permet d'arriver
			à une partie finis ou un état du plateau qui pourrait exister. 

		4.1.3. Problème

			* Comment générer arbre* d'états, dans une partie à plusieurs joueurs ?
				Il existe plusieurs style d'algorithme* permettant de résoudre des
			problèmes différents. Pour notre sujet, nous devons utiliser des algorithmes 
			s'appliquant à la théorie des jeux. Le principe de l'algorithme MinMax*
			permettrait de trouver un déplacement idéal sur le plateau du jeu Tron, cet
			algorithme fonctionne pour les jeux à deux joueurs à sommes nulle, nous ne
			pouvons pas l'utiliser. En essayant de s'inspirer de son principe, nous
			pourrons générer un parcour dans l'arbre étant évalué par une heuristique*.  
				
		4.1.4. Approche possibles
			
			* Algorithme Paranoide
				
				Fonctionnement :
				
				L'algorithme Paranoide fonctionne sur le principe de celui de MinMax,
				une des différences qui éxiste entre ces deux algorithmes est qu'il
				s'applique sur la théorie des jeux pour plusieurs joueurs. Cet
				algorithme part du principe que tout les joueurs du terrain sont
				contre lui, tout les joueurs adverse choisiront donc la perte 
				maximum du joueur et lui minimisera sa perte. 
								

				Avantage et inconvénient :
				
				L'algorithme Paranoide à hauteur de sa profondeur de recherche* ne
				pourra pas se tromper. En revanche nous ne sommes pas garantit que
				le meilleur coups ne soit pas le pire coups au tour suivant.  

			* Algorithme Monte-Carlo

				Fonctionnement : 
				
				L'alogrithme Monte-Carlo fonctionne sur le principe de l'aléatoire.
				Cet algorithme joue des actions aléatoire... A completer

				Avantage et inconvénient :

				L'algorithme Monte-Carlo est très rapide, mais ne donne pas toujours
				la réponse du problème posé.				

		4.1.5. Approche utilisée
			
			* Fusion de plusieurs algorithme
				Afin d'obtenir un maximum de résultat dans la phase de l'
			analyse nous devons avoir un algorithme rapide. L'algorithme Monte-Carlo
			pourrait être une solution sur la rapidité, avec l'expérience du groupe,
			nous avons choisit l'algorithme Paranoide qui semble être le plus facile à
			réaliser dans le temps de ce projet. Pour optimiser le temps de calcul, nous
			avons rajouter 2 techniques pour améliorer la rapidité.

			* Elagage alpha-bêta
				L'élagage alpha-bêta est une technique permttant de couper les
			branches de l'arbres qui réprésente des sous-arbres possédant des valeurs
			qui ne contribuent pas au calcul minmax de notre algorithme.

			* Negamax :
				Technique permettant de changer la fonction d'évaluation, cela
			permet d'éviter les récursions de MinMax entre la maximisation et
			minimisation. Chaques joueurs maximisera son évualation qui est opposé à
			celui de son adversaire.

		4.1.6. Remarques sur les résultats obtenus
			
			* Aucun déplacement trouvé
				Lorsque l'algorithme paranoide perçoit la fin de son équipe dans
			toute ces branches, vu que l'heuristique est une valuation par rapport au 
			terrain (en effet vu que l'équipe est morte l'heuristique renverra 0). Il
			sera incapable de faire la différence entre ces états menant vers sa fin, 
			l'alogirthme renverra la premiere action, donné dans la liste d'actions
			possible. Pour éviter ce genre d'évenement, nous avons ajouter à
			l'algorithme une détection d'action permettant de déterminer si l'algorithme
			n'a pas trouvé de solution. Dans ce cas l'algorihtme choisira parmis la
			liste d'actions un coup aléatoire, qui ne tuera pas le joueur.

			* Phénomène de profondeur MinMax
				Nous avons observer un phénomène lors de nos tests de l'algorithme
			paranoide. Le joueur seul pense que la partie est finis et passe dans le
			mode survie de l'algorithme expliqué ci-dessus*, alors qu'il avait moyen de
			s'en sortir.

				En effet nous avons vu que l'une des faiblesses de cet algorithme 
			est que nous ne sommes pas garantit de la fiabilité du coup choisit au tour
			suivant. Vu que le joueur seul a une vision plus profonde de la partie que
			ses adversaires, il percoit l'opportunité de ses adversaires de le tuer.
			Mais si cette opportunité est vu dans une profondeur plus grande que celle
			de l'adversaire alors elle n'est pas garantit d'arriver car l'adversaire
			jouera le meilleur coup à hauteur de sa profondeur. Ce phénomène fournit une
			preuve de la limite de puissance de l'algorithme paranoide. 

				Nous avons vu l'impact le plus génant de ce phénomène, mais nous
			pouvons aussi remettre en cause avec le même principe, tout les calculs pris
			en compte lorsque la profondeur d'un joueur dépasse celle de son adversaire.
			En effet lorsque les calculs sont fait dans des hauteurs de profondeur
			accessible par tout les joueurs, les joueurs perçevront les états futurs.
			En revanche dès que la profondeur dépasse la profondeur de l'adversaire, le
			joueur obtient une prévision des meilleurs états futurs de son adversaire.
			Il jouera le meilleur coup possible en fonction de ces états, mais ce coup
			n'étant pas calculé dans les autres états futurs possibles, ce coup ne sera
			plus le meilleur coup possible (remarque: dans la majorité des cas il reste
			un coup assez viable).
 
		4.1.7. Pistes d'amélioration

			* Concernant l'optimisation de temps d'éxecution
				Lorsque l'algorithme détecte à hauteur de sa profondeur que la 
			partie est finis, il arrete de jouer le meilleur coups possible et joue des
			coups aléatoire. Apres chaques coup l'algorithme est rappelé, ce qui
			ralentit grandement l'analyse de résultat. Nous pourrions retirer le mode
			survie de l'algorithme, et déclarer un vainqueur par abandont. Mais nous
			avons vu que l'algorithme peut se tromper lorsque sa profondeur est plus
			grande que l'adversaire.
				
				Nous avons observé plusieurs fois des situations où l'algorithme
			prevoit qu'il va perdre. Ces prévisions ont 75% d'être vrais.
			
				Conclusion, si nous utilisons cet amélioration nous perdrons en
			précision de résultat mais nous gagneront plus en temps d'execution de
			l'analyse.

			* Concernant le phénomène de profndeur
				Il existe l'algorithme Expctimax qui va jouer des coups aléatoire et
			faire une moyenne. Nous pourrions garder notre algorithme Paranoide, puis
			lorsque la profondeur dépasse celle de l'adversaire alors les coups des
			adversaire seront joué aléatoirement et une moyenne sera faite à partir de
			ce niveau. 
			 
			
	4.2. Heuristique
		4.2.1. Elements technique
			
			* Heuristique (4.1.3.) :
				Une heuristique permet de faire une valuation d'un états, afin de
				différencier un état d'un autre. Ces differences permettent aux
				algorithmes de faire un choix entre plusieurs actions.

		4.2.2. Nécessités
			
			* Evaluation du plateau
				Lors d'une partie de jeu Tron, le joueur qui possède la plus grosse
			zone de contrôle sur le plateau gagnera. En partant sur cet stratégie,
			l'heuristique devra calculer la zone de controle des joueurs.
				 
		4.2.3. Problème

			* Comment pourrions nous faire une heuristique rapide, mais aussi donnant
			des résultats fiables ?
				L'heuristique devra évaluer la valeur d'une situation. Devant
			parcourir tout le plateau, pour évaluer un état, il faudra beaucoup de 
			calculs pour obtenir une valeur précise. Il nous faudra être suffisamment
			rapide sur cette partie afin de générer assez de tests pour l'analyse des
			configurations de la partie.
				
		4.2.4. Approche possibles
			
			* Parcour de recherche BFS pour un joueur
				Ce parcour, va calculer la distance de chaques cases depuis la
			position du joueur, cette opération est répeté pour tout les joueurs.
			L'attribution de la case est donné à l'équipe possédant la plus petite
			distance sur cette case. La compléxité de l'heuristique est de 
			n * m * c.
			* Parcour de recherche BFS joueur par joueur
				Dans cette approche, le parcour BFS va s'étendre à partir de tout 
			les joueurs. La compléxité de l'heuristique est de n*m.

			* Evaluation de la zone de controle en nombre de case possédé
				Lorsque nous évaluons un plateau en nombre de case, minimiser
			signifie reduire la taille de la zone du terrain controlé par le joueur.
			Sauf que réduire la zone adversaire ne signifie pas forcement augmenter la
			sienne. L'algorithme paranoide minimise la zone du joueur lors de la 
			simulation du coup de son adversaire, alors que l'adversaire à son tour
			essayera de maximiser sa zone. Nous nous retrouvons dans un états qui n'a
			pas été prévus par l'algorithme et donc fausse toute la perception des etats
			futur calculé par l'algorithme.

			Insérer image tag : 1 -> nbr_case.png Légende : "bleu = 20 cases/ 20% ; rouge = 82 cases/ 80%"

			Insérer image tag : 2 -> nbr_case_mini.png Légende : "bleu = 14 cases/ 50% ; rouge = 14 cases/ 50%"

			Insérer image tag : 3-> nbr_case_maxi.png Légende : "bleu = 35 cases/ 35% ; rouge = 66 cases/ 65%"
			 
			* Evaluation de la zone de controle en pourcentage du terrain jouable
			possédé
				L'évaluation d'une zone controle convertis en pourcentage de
			controle du terrain jouable, permet d'obtenir une heuristique à sommes nulle
			. En effet lorsqu'un joueur maximise son pourcentage de controle du terrain,
			il diminuera celui de son adversaire et vice-versa.
				
		4.2.5. Approche utilisée

			* Parcour de recherche et Optimisation
				Il est évident que nous allons utiliser l'approche avec la meilleur
			compléxité. Cette méthode est rapide pour sa fiabilité, mais lors de
			l'éxecution de l'analyse de donnée, cette partie est la plus couteuse de 
			notre simulation.
			
				Notre principale objectif est d'obtenir suffisament de résultat,
			afin de déduire quelles seront les paramètres idéaux pour résoudre la
			problématique. Avec notre calcul de la zone de contrôle, les estimations de
			calcul s'élèvent à plus de 48H.

				 Pour améliorer le temps de calcul de la zone de controle, on
			suppose que le joueur seul possède moins de terrain que la coalition et
			qu'une zone qu'il ne controle pas est une zone appartenant à la coalition.
				
				Avec ces suppositions on remarque que les cases isolé (voir case 
			grise de l'image tag 2), n'appartiennent à aucune équipe. Avec cette
			supposition on constate qu'une case que ne possède pas le joueur seul n'est
			pas forcement une case appartenant à son adversaire. Utiliser ce principe
			nous ferait gagner en temps de calcul mais nous perdrons en fiabilité.

				Pour génerer cette amélioration, l'heuristique calculera la zone de 
			controle de chaques équipes, le parcour BFS sera interrompu lorsque le
			joueur seul ne peut plus obtenir de case pour sa zone de controle. En effet
			avec cette solution la zone de contrôle des joueurs de la coalition risque
			de ne plus être calculé en entier. Pour obtenir la zone de controle de la
			coalition, une approximation de celle-ci va s'ajouter aux calculs de
			l'heuristique. 
				
				A partir de la zone de contrôle du joueur seul et la taille du
			terrain jouable (le nombre de case libre), nous pouvons en déduire une
			approximation de la zone controlé par la coallition.
			(ex : 	
				zone controle seul = (cases possédé / terrain jouable) * 100
				zone controle coalition = 100 - zone controle seul
			)

			Remarque: Dans cette approche, nous ne sommes plus obligé de calculer toute
			les cases du terrain jouable. En effet toute les cases d'une zone ne sont
			plus calculé lorsqu'une zone est plus grande que la zone du joueur seul.

			Insérer image tag : 4-> heurisitique_interruption.png Légende : "Calcul de la zone de controle du joueur 3"

				Avec cette méthode, nous gagnons en temps d'éxecution et nous
			perdons en fiabilité (à cause des cases isolé et constété). Le moyen
			d'augmenter la fiabilité serait d'améliorer l'approximation, mais sans
			calculer la zone de controle de la coalition. L'estimation de calcul
			s'élèvent désormais à 24H, ce qui est toujours élevé.
				
				On remarque qu'un joueur trop éloigné, n'aura pas d'impact sur le 
			calcul de la zone de controle du joueur seul. On considera un joueur trop
			éloigné lorsqu'il est éloigné sur une distance de deux fois supérieur à 
			celle de la profondeur du joueur seul. Avec une distance deux fois supérieur
			à celle de la profondeur du joueur seul, meme si les deux joueurs se
			rapprochent tout le long des tours, la distance est telle, qu'a la fin de la
			recherche ils ne pourraient toujours pas interagir l'un avec l'autre.

				Vu que l'heuristique va calculer une zone qui n'a pas d'impact sur la
			zone de controle du joueur seul, nous pouvons supprimer tout les joueurs qui
			sont trop éloigné du joueur seul. En effet au début du calcul de
			l'heuristique, nous initialisons la position de départ de chaques joueurs.
			Grace à la distance de mannathan entre les joueurs, nous pouvons déterminer
			les joueurs assez proche et les prendre en considération lors du calcul des
			zones.
 
			Remarques: Perde en fiablilité n'est pas forcement un point négatif lors de
			la phase d'analyse. En effet grâce à l'optimisation des temps de calcul nous
			pouvont génerer beaucoup plus de résultat. Parmis ses résultats les petits
			erreurs de fiabilité seront noyées dans la masse d'information, car nos
			erreurs de fiabilité ne sont pas une généralité mais des cas tres
			particulier de partie.
 
			* Evaluation de la zone de controle
			(rien trouvé mise a part une répétition sur l'approche)
		4.2.6. Remarques sur les résultats obtenus

			* Maximiser, minimiser un nombre de case

				Avec une heuristique basé sur les nombres de case controlé par une
			équipe, nous avons constaté que le joueurs seul essayait d'augmenter sa zone
			alors que les joueurs de la coalition essayaient de réduire la taille du 
			joueur seul, dans l'algorithme Paranoide la stratégie des dans camps doit
			être identique, ce qui n'est pas le cas avec une tel heuristique.

				 
		4.2.7. Pistes d'amélioration
				Une autre solution serai de modifier l'heuristique en ajoutant à sa 
			valuation d'un plateau, le nombre de joueur présent sur le plateau, le
			nombre de tour, la taille de la zone de controle du terrain adverse. Ce qui
			permettrait de rajouter plus d'évaluation sur un etat lorsqu'un joueur
			possède une zone de controle faible.
	4.3. Conclusion
		4.3.1. Observation sur les résultats des coups impliqué par l'heuristique
			* Déplacement serpent
				Lorsque un joueur ne peut plus agir sur la zone de l'adversaire à
			hauteur de sa profondeur, l'algorithme se déplace sur toute les cases
			qu'il peut parcourir.

			Insérer image tag : 5-> serpent.png Légende : "Observation d'un déplacement en serpent"

			* Abandont lors de la mort
				
				Dès que l'algorithme détecte sa mort à hauteur de sa profondeur
			(donc cette information peut être fausse), tout les états futur ne
			peuvent être différencier, nous avons rajouter un mode survie le permettant
			de continuer à survivre en esperant que la situation puisse s'améliorer.
			
			Insérer image tag : 6-> anti_suicide.png Légende : "Changement de déplacement avec le filtre de situation"

			* Sacrifice

				Le mode survie doit pouvoir faire la différence entre un suicide
			pour l'équipe et un abandont. Un joueur de la coalition peut s'apercevoir
			que sa présence sur le plateau n'est pas bénéfique à l'équipe, il devra
			se retirer du plateau en se tuant.

			Insérer image tag : 7-> sacrifice.png Légende : "Sacrifice pour l'équipe"

			* Stratégie

				Dans la stratégie de posséder une plus grande zone de
			controle que son adversaire, se rapprocher de son adversaire est un bonne
			manière de diminuer la zone de controle de son adversaire. Cette situation
			peut se produire lorsqu'un joueur peut diminuer la zone de son adversaire
			tout en augmentant la sienne. Dans le même cas de situation un joueur peut
			enfermer un adversaire dans une partie du terrain.

			Insérer image tag : 8-> rapprochement.png Légende : "Observation de rapprochement des joueurs"
			
			Insérer image tag : 9-> enfermement.png Légende : "Observation d'un enfermement"

			Ces comportements sont née de l'heuristique, mise à part le mode survie.
			Changer l'heuristique affectera ces comportements.
9. Conclusion
	
	Résumé sur l'enrichissement personnel
		Vincent: Ce projet m'as permis de découvrir plusieurs phénomène sur l'algorithme
		MinMax. J'ai beaucoup appris sur l'impacte que peut avoir une heuristique sur un
		algorithme. J'ai pu me documenter sur plusieurs autres algorithmes. Réaliser tout
		ces optimisations pour le modules d'analyse, m'a fait comprendre que l'on peut
		passer par d'autre chemin pour un résultat identique mais plus rapide. Travailler
		avec ce groupe m'as permis d'apprendre de nouvelle méthode de travail, et aussi
		des nouveaux outils en informatique.

	Résumé perspectives envisagées, appréciation perso, poursuite...
		Vincent: 
			Nous pourrions utiliser l'algorithme Monte-Carlo pour gagner du temps de
		calcul. Ce qui permettrait de supprimer l'heuristique, qui possède une très grande
		importance dans l'algorithme. Imaginer une solution sans heuristique permettrait
		d'enlever plusieurs problème.

			Mener une étude sur les positions idéal que pourrait avoir les joueurs sur
		le plateau serait très enrichissant.
		
		